#!/usr/bin/env python

import rospy
from nav_msgs.msg import Path
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import String
import numpy as np
import time
from scipy.spatial.transform import Rotation

if __name__ == '__main__':
    rospy.init_node('panda_path_control_test')

    pub = rospy.Publisher('/panda/path', Path, queue_size=1)
    pub_ee = rospy.Publisher('/panda/set_ee_link', String, queue_size=1)
    rospy.sleep(0.5)

    # Change the end effector
    strEE = String()
    strEE.data = "pandaMocap"
    pub_ee.publish(strEE)
    rospy.sleep(0.5)

    poses = []
    t = 2 + rospy.Time.now().secs + rospy.Time.now().nsecs / 1000000000
    for theta in np.arange(0, 6 * np.pi, 0.01):
        p = PoseStamped()
        
        p.pose.position.x = 0.03*np.sin(theta) + 0.04*np.sin(1.5*theta) + 0.55
        p.pose.position.y = 0.15*np.sin(theta) + 0.07*np.sin(2.0*theta) - 0.10
        p.pose.position.z = 0.04*np.sin(theta) + 0.06*np.sin(2.5*theta) + 0.42
        
        R = Rotation.from_euler('XYZ', [-0.3, 0.0, 0.1*np.sin(theta)+0.2])
        # R = Rotation.from_euler('XYZ', [0.1*np.sin(theta), 0.1*np.sin(theta)-0.3, 0.1*np.sin(theta)+0.2])
        q = R.as_quat()
        p.pose.orientation.x = q[0]
        p.pose.orientation.y = q[1]
        p.pose.orientation.z = q[2]
        p.pose.orientation.w = q[3]
        poses.append(p)

        t += 0.005
        p.header.stamp.secs = t // 1
        p.header.stamp.nsecs = (t - (t // 1)) * 1000000000
    
    msg = Path()
    msg.poses = poses

    pub.publish(msg)