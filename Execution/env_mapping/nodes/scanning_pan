#!/usr/bin/env python

""" Scans the scene with panda for Rtabmap
 Created: 11/17/2021
"""

__author__ = "Mike Hagenow"

import rospy
import time
from std_msgs.msg import String, Float64
from panda_ros_msgs.msg import HybridPose
from tf2_msgs.msg import TFMessage
from scipy.spatial.transform import Rotation as ScipyR
import numpy as np
import rosbag
import rospkg
import tf2_ros
from scipy.spatial.transform import Slerp
import subprocess32

class PandaReg:
    def __init__(self):
        rospy.init_node('panda_pan')

    def linearInterpolation(self,start,end,val):
        return start + (end-start)*val

    def runRR(self):
        pub = rospy.Publisher('/panda/hybrid_pose', HybridPose, queue_size=1)
        pub_mapping = rospy.Publisher('/mappingToggle', String, queue_size=1)
        pub_done = rospy.Publisher('/panda/pan', String, queue_size=1)
        tfBuffer = tf2_ros.Buffer()
        listener = tf2_ros.TransformListener(tfBuffer)

        rospy.sleep(0.5)

        strMapping = String()
        strMapping.data = "on"
        pub_mapping.publish(strMapping)

        strDone = String()
        strDone.data = "start"
        pub_done.publish(strDone)

        rospy.sleep(2.0) # give a second for kinect driver to start

        hpose = HybridPose()
        hpose.sel_vector = [1,1,1,1,1,1]
        hpose.wrench.force.x = 0.0
        hpose.wrench.force.y = 0.0
        hpose.wrench.force.z = 0.0
        hpose.wrench.torque.x = 0.0
        hpose.wrench.torque.y = 0.0
        hpose.wrench.torque.z = 0.0
        hpose.constraint_frame.x = 0.0
        hpose.constraint_frame.y = 0.0
        hpose.constraint_frame.z = 0.0
        hpose.constraint_frame.w = 1.0

        try:
            # Get current pose from TF2
            # listener.waitForTransform('panda_link0', 'panda_ee', rospy.Time(), rospy.Duration(2.0))
            trans = tfBuffer.lookup_transform("panda_link0", "panda_ee", rospy.Time(), rospy.Duration(4.0))
            x = trans.transform.translation.x; y = trans.transform.translation.y; z = trans.transform.translation.z
            qx = trans.transform.rotation.x; qy = trans.transform.rotation.y; qz = trans.transform.rotation.z
            qw = trans.transform.rotation.w
            starting = np.array([x, y, z])

        except Exception as e:
            print(str(e))
            return

        ###################################
        # Run the registration sequence 
        ###################################
        R_start = ScipyR.from_quat([qx,qy,qz,qw])
        
        # Left Right
        max_theta = 8 * np.pi
        for theta in np.arange(0, max_theta, 0.008):
            
            if not rospy.is_shutdown():
                cam_motion_rotated = R_start.apply(np.array([0.1 * theta/(max_theta), 0.15*np.sin(0.5*theta), 0.0]))
                hpose.pose.position.x = cam_motion_rotated[0] + starting[0]
                hpose.pose.position.y = cam_motion_rotated[1] + starting[1]
                hpose.pose.position.z = cam_motion_rotated[2] + starting[2]

                R_cam = ScipyR.from_euler('XYZ', [-0.2*np.sin(0.5*theta), 0.0, 0.0])

                q = (R_start * R_cam).as_quat()
                hpose.pose.orientation.x = q[0]
                hpose.pose.orientation.y = q[1]
                hpose.pose.orientation.z = q[2]
                hpose.pose.orientation.w = q[3]

                pub.publish(hpose)
                time.sleep(0.005)
            else:
                return

        time.sleep(0.1)

        strDone = String()
        strDone.data = "end"
        pub_done.publish(strDone)

        time.sleep(0.5)
        strMapping.data = "off"
        pub_mapping.publish(strMapping)
        time.sleep(2.0)

if __name__ == "__main__":
    rigid = PandaReg()
    rigid.runRR()
    rospy.spin()





