#!/usr/bin/env python

""" Scans the scene with panda for Rtabmap
 Created: 11/17/2021
"""

__author__ = "Mike Hagenow"

import rospy
import time
from std_msgs.msg import String, Float64
from hybrid_controller.msg import HybridPose
from tf2_msgs.msg import TFMessage
from scipy.spatial.transform import Rotation as ScipyR
import numpy as np
import rosbag
import rospkg
import tf2_ros
from scipy.spatial.transform import Slerp
import subprocess32

class PandaReg:
    def __init__(self):
        rospy.init_node('panda_pan')

    def linearInterpolation(self,start,end,val):
        return start + (end-start)*val

    def runRR(self):

        pub = rospy.Publisher('/panda/hybrid_pose', HybridPose, queue_size=1)
        pub_mapping = rospy.Publisher('/mappingToggle', String, queue_size=1)
        pub_done = rospy.Publisher('/panda/pan', String, queue_size=1)
        tfBuffer = tf2_ros.Buffer()
        listener = tf2_ros.TransformListener(tfBuffer)

        rospy.sleep(0.5)

        strMapping = String()
        strMapping.data = "on"
        pub_mapping.publish(strMapping)

        strDone = String()
        strDone.data = "start"
        pub_done.publish(strDone)

        hpose = HybridPose()
        hpose.sel_vector = [1,1,1,1,1,1]
        hpose.wrench.force.x = 0.0
        hpose.wrench.force.y = 0.0
        hpose.wrench.force.z = 0.0
        hpose.wrench.torque.x = 0.0
        hpose.wrench.torque.y = 0.0
        hpose.wrench.torque.z = 0.0
        hpose.constraint_frame.x = 0.0
        hpose.constraint_frame.y = 0.0
        hpose.constraint_frame.z = 0.0
        hpose.constraint_frame.w = 1.0

        try:
            # Get current pose from TF2
            # listener.waitForTransform('panda_link0', 'panda_ee', rospy.Time(), rospy.Duration(2.0))
            trans = tfBuffer.lookup_transform("panda_link0", "panda_ee", rospy.Time(), rospy.Duration(4.0))
            x = trans.transform.translation.x; y = trans.transform.translation.y; z = trans.transform.translation.z
            qx = trans.transform.rotation.x; qy = trans.transform.rotation.y; qz = trans.transform.rotation.z
            qw = trans.transform.rotation.w
            starting = np.array([x, y, z])

            # rot point relative to EE
            trans = tfBuffer.lookup_transform("panda_ee", "camera_base", rospy.Time(), rospy.Duration(4.0))
            rot_rel = np.array([trans.transform.translation.x, trans.transform.translation.y, trans.transform.translation.z])

        except Exception as e:
            print(str(e))
            return


        #############################
        # Sleep for Driver to Start #
        #############################
        rospy.sleep(3.5)

        ###################################
        # Run the registration sequence 
        ###################################
        R_start = ScipyR.from_quat([qx,qy,qz,qw])

        starting_offset = R_start.apply(rot_rel)+starting

        # Up Down
        max_theta = 2 * np.pi
        for theta in np.arange(0, max_theta, 0.015):
            
            if not rospy.is_shutdown():
                R_cam = ScipyR.from_euler('XYZ', [0.0, -0.2*np.sin(theta), 0.0])
                R_curr = R_start * R_cam
                q = R_curr.as_quat()
                hpose.pose.orientation.x = q[0]
                hpose.pose.orientation.y = q[1]
                hpose.pose.orientation.z = q[2]
                hpose.pose.orientation.w = q[3]
                
                ee_offset_temp = R_curr.apply(-rot_rel)
                hpose.pose.position.x = starting_offset[0] + ee_offset_temp[0]
                hpose.pose.position.y = starting_offset[1] + ee_offset_temp[1]
                hpose.pose.position.z = starting_offset[2] + ee_offset_temp[2]

                pub.publish(hpose)
                time.sleep(0.01)
            else:
                return
        
        # Left Right
        max_theta = 2 * np.pi
        for theta in np.arange(0, max_theta, 0.015):
            
            if not rospy.is_shutdown():
                R_cam = ScipyR.from_euler('XYZ', [-0.2*np.sin(theta), 0.0, 0.0])
                R_curr = R_start * R_cam
                q = R_curr.as_quat()
                hpose.pose.orientation.x = q[0]
                hpose.pose.orientation.y = q[1]
                hpose.pose.orientation.z = q[2]
                hpose.pose.orientation.w = q[3]
                
                ee_offset_temp = R_curr.apply(-rot_rel)
                hpose.pose.position.x = starting_offset[0] + ee_offset_temp[0]
                hpose.pose.position.y = starting_offset[1] + ee_offset_temp[1]
                hpose.pose.position.z = starting_offset[2] + ee_offset_temp[2]

                pub.publish(hpose)
                time.sleep(0.01)
            else:
                return

        time.sleep(0.1)

        strDone = String()
        strDone.data = "end"
        pub_done.publish(strDone)

        time.sleep(0.5)
        strMapping.data = "off"
        pub_mapping.publish(strMapping)
        time.sleep(2.0)

if __name__ == "__main__":
    rigid = PandaReg()
    rigid.runRR()
    rospy.spin()





