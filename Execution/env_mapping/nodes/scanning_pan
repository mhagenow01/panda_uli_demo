#!/usr/bin/env python

""" Scans the scene with panda for Rtabmap
 Created: 11/17/2021
"""

__author__ = "Mike Hagenow"

import rospy
import time
from std_msgs.msg import String, Float64
from panda_ros_msgs.msg import HybridPose
from tf2_msgs.msg import TFMessage
from scipy.spatial.transform import Rotation
import numpy as np
import rosbag
import rospkg
import tf2_ros
from scipy.spatial.transform import Slerp
import subprocess32

class PandaReg:
    def __init__(self):
        rospy.init_node('panda_pan')

    def linearInterpolation(self,start,end,val):
        return start + (end-start)*val

    def runRR(self):
        pub = rospy.Publisher('/panda/hybrid_pose', HybridPose, queue_size=1)
        pub_ee = rospy.Publisher('/panda/set_ee_link', String, queue_size=1)
        pub_chain = rospy.Publisher('/panda/set_kinematic_chain', String, queue_size=1)
        pub_mapping = rospy.Publisher('/mappingToggle', String, queue_size=1)
        pub_done = rospy.Publisher('/panda/pan', String, queue_size=1)
        tfBuffer = tf2_ros.Buffer()
        listener = tf2_ros.TransformListener(tfBuffer)

        rospy.sleep(0.5)

        strMapping = String()
        strMapping.data = "on"
        pub_mapping.publish(strMapping)

        strDone = String()
        strDone.data = "start"
        pub_done.publish(strDone)

        # Change the end effector
        strEE = String()
        strEE.data = "pandaOrbital"
        pub_ee.publish(strEE)
        strChain = String()
        strChain.data = "pandaFlange"
        pub_chain.publish(strChain)
        rospy.sleep(2.0)

        hpose = HybridPose()
        hpose.sel_vector = [1,1,1,1,1,1]
        hpose.wrench.force.x = 0.0
        hpose.wrench.force.y = 0.0
        hpose.wrench.force.z = 0.0
        hpose.wrench.torque.x = 0.0
        hpose.wrench.torque.y = 0.0
        hpose.wrench.torque.z = 0.0
        hpose.constraint_frame.x = 0.0
        hpose.constraint_frame.y = 0.0
        hpose.constraint_frame.z = 0.0
        hpose.constraint_frame.w = 1.0

        #Interpolate to the starting position
        starting = [0.45, 0.0, 0.31]
        startingR = Rotation.from_euler('XYZ', [0.0, 0.0, 0.0])
        q_startingR = startingR.as_quat()

        try:
            # Get current pose from TF2
            # listener.waitForTransform('panda_link0', 'panda_ee', rospy.Time(), rospy.Duration(2.0))
            trans = tfBuffer.lookup_transform("panda_link0", "panda_ee", rospy.Time(), rospy.Duration(4.0))
            x = trans.transform.translation.x; y = trans.transform.translation.y; z = trans.transform.translation.z
            qx = trans.transform.rotation.x; qy = trans.transform.rotation.y; qz = trans.transform.rotation.z
            qw = trans.transform.rotation.w

        except Exception as e:
            print(str(e))
            return

        # Set up SLERP for interpolation
        rots = np.array([[qx,qy,qz,qw],[q_startingR[0],q_startingR[1],q_startingR[2],q_startingR[3]]])
        print(rots)
        key_rots = Rotation.from_quat(rots)
        print(len(key_rots))
        key_times = [0,1]
        slerp = Slerp(key_times, key_rots)

        # 100 samples per second
        num_interp_samples = 200
        for jj in range(0,num_interp_samples):
            hpose.pose.position.x = self.linearInterpolation(x, starting[0], float(jj) / num_interp_samples)
            hpose.pose.position.y = self.linearInterpolation(y, starting[1], float(jj) / num_interp_samples)
            hpose.pose.position.z = self.linearInterpolation(z, starting[2], float(jj) / num_interp_samples)
            hpose.pose.orientation.x = slerp([float(jj) / num_interp_samples]).as_quat()[0][0]
            hpose.pose.orientation.y = slerp([float(jj) / num_interp_samples]).as_quat()[0][1]
            hpose.pose.orientation.z = slerp([float(jj) / num_interp_samples]).as_quat()[0][2]
            hpose.pose.orientation.w = slerp([float(jj) / num_interp_samples]).as_quat()[0][3]
            pub.publish(hpose)
            time.sleep(0.01)

        time.sleep(1.0)

        ###################################
        # Run the registration sequence 
        ###################################
        
        # Left Right
        max_theta = 8 * np.pi
        for theta in np.arange(0, max_theta, 0.008):
            
            if not rospy.is_shutdown():
                hpose.pose.position.x = - 0.0 * np.sin(0.5*theta) + 0.1 * theta/(max_theta) + starting[0]
                hpose.pose.position.y = 0.15 * np.sin(0.5*theta) + starting[1]
                hpose.pose.position.z = 0.0 * np.sin((0.5*theta)) + starting[2]

                R = Rotation.from_euler('XYZ', [-0.2*np.sin(0.5*theta), -0.00*(theta/(4*np.pi)), 0.0*np.abs(np.sin(0.5*theta))])
                q = R.as_quat()
                hpose.pose.orientation.x = q[0]
                hpose.pose.orientation.y = q[1]
                hpose.pose.orientation.z = q[2]
                hpose.pose.orientation.w = q[3]

                pub.publish(hpose)
                time.sleep(0.005)
            else:
                return

        time.sleep(0.1)

        strDone = String()
        strDone.data = "end"
        pub_done.publish(strDone)

        time.sleep(0.5)
        strMapping.data = "off"
        pub_mapping.publish(strMapping)
        time.sleep(2.0)

if __name__ == "__main__":
    rigid = PandaReg()
    rigid.runRR()
    rospy.spin()





